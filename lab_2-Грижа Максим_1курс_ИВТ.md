## Лабораторная работа №2.

## Тема: Указатели, арифметика указателей.

## Задача 1 – Тройной указатель и динамическая память

### Постановка задачи
 Внутри функции int main(void) { /*...*/ } определите указатель double ***pointer = NULL;. Ини
циализируйте этот указатель адресом другого указателя типа double **, который указывает на переменную
 double *, которая указывает на double. Используйте pointer для записи и чтения значения 2.0 в сегмент
 оперативной памяти для double.
 Требования:
 • Используйте функции типа *alloc(...) для выделения оперативной памяти под динамические объекты
 double **, double * и double.
 • Запишите и выведите число, указанное в блоке double на диаграмме, на экран, используя указатель double
 ***pointer = NULL;.
 • Используйте функцию free(...) для освобождения оперативной памяти, выделенной под динамические объ
екты с применением переменной pointer.
 • Запишите всё решение в одну строку одним выражением (statement).

### Список идентификаторов

| Имя переменной | Тип данных   | Смысловое обозначение                                           |
|----------------|--------------|------------------------------------------------------------------|
| pointer        | double ***    | Тройной указатель, указывающий на указатель на указатель double |

### Код программы

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    double ***pointer = NULL;
    pointer = malloc(sizeof(double**)), *pointer = malloc(sizeof(double*)), **pointer = malloc(sizeof(double)), ***pointer = 2.0, printf("%g\n", ***pointer), free(**pointer), free(*pointer), free(pointer);
    return 0;
}

```
### Результаты работы программы
![image](https://github.com/user-attachments/assets/d38eee19-5def-4837-a1ed-abff0819d839)

## Задача 2 – Сложение двух чисел

### Постановка задачи 
 Напишите программу, которая складывает два числа с использованием указателей на эти числа.

### Список идентификаторов

| Имя переменной | Тип данных | Смысловое обозначение                                 |
|----------------|------------|--------------------------------------------------------|
| a              | int        | Первое вводимое число                                  |
| b              | int        | Второе вводимое число                                  |
| pa             | int*       | Указатель на переменную `a`                            |
| pb             | int*       | Указатель на переменную `b`                            |
| sum            | int        | Сумма двух чисел, на которые указывают `pa` и `pb`     |


### Код программы
```c
#include <stdio.h>

int main(void) {
    int a, b;
    int *pa = &a, *pb = &b;

    printf("Enter two integers: ");
    if (scanf("%d %d", pa, pb) != 2)
        return 1;

    int sum = *pa + *pb;
    printf("Sum: %d\n", sum);

    return 0;
}

```
### Результаты работы программы
![image](https://github.com/user-attachments/assets/bc9362d0-fd09-4b04-aef3-dbb2d79f4cb6)

## Задача 3 – Нахождение максимума из двух чисел

### Постановка задачи 
Напишите программу, которая находит максимальное число из двух чисел, используя указатели на эти числа.

### Список идентификаторов

| Имя переменной | Тип данных | Смысловое обозначение                                      |
|----------------|------------|-------------------------------------------------------------|
| x              | int        | Первое вводимое число                                       |
| y              | int        | Второе вводимое число                                       |
| px             | int*       | Указатель на переменную `x`                                 |
| py             | int*       | Указатель на переменную `y`                                 |
| max            | int        | Максимальное значение из двух чисел `x` и `y`               |


### Код программы
```c
#include <stdio.h>

int main(void) {
    int x, y;
    int *px = &x, *py = &y;

    printf("Enter two integers: ");
    if (scanf("%d %d", px, py) != 2)
        return 1;

    int max = (*px > *py) ? *px : *py;
    printf("Maximum: %d\n", max);

    return 0;
}

```
### Результаты работы программы
![image](https://github.com/user-attachments/assets/3fbf3ab6-99f5-4a31-b8a1-a28d5e16dd0e)

## Задача 4 – Динамический массив с плавающей точкой

### Постановка задачи 
Напишите программу, которая создаёт одномерный динамический массив из чисел с плавающей точкой двой
ной точности, заполняет его значениями с клавиатуры и распечатывает все элементы этого массива, используя
 арифметику указателей (оператор +), а не оператор доступа к элементу массива []

### Список идентификаторов

| Имя переменной | Тип данных    | Смысловое обозначение                                        |
|----------------|----------------|----------------------------------------------------------------|
| n              | size_t         | Количество элементов в массиве                                |
| arr            | double*        | Указатель на динамически выделенный массив типа `double`      |
| i              | size_t         | Счётчик цикла для ввода и вывода элементов массива            |

### Код программы
```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    size_t n;
    printf("Enter number of elements: ");
    if (scanf("%zu", &n) != 1) {
        fprintf(stderr, "Failed to read the number of elements\n");
        return 1;
    }

    double *arr = malloc(n * sizeof(double));
    if (!arr) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }

    printf("Enter %zu double values:\n", n);
    for (size_t i = 0; i < n; ++i) {
        if (scanf("%lf", arr + i) != 1) {
            fprintf(stderr, "Failed to read element %zu\n", i);
            free(arr);
            return 1;
        }
    }

    printf("Array elements:\n");
    for (size_t i = 0; i < n; ++i) {
        // access via pointer arithmetic, not arr[i]
        printf("%f\n", *(arr + i));
    }

    free(arr);
    return 0;
}

```
### Результаты работы программы
![image](https://github.com/user-attachments/assets/47a44760-761b-44c4-8c4a-2f9b8ae8ed9c)

## Задача 5 – Обратный порядок элементов массива

### Постановка задачи 
 Выведите элементы динамического массива целых чисел в обратном порядке, используя указатель и операцию
 декремента (--).

### Список идентификаторов

| Имя переменной | Тип данных | Смысловое обозначение                                                  |
|----------------|------------|-------------------------------------------------------------------------|
| n              | size_t     | Количество элементов массива                                           |
| arr            | int*       | Указатель на динамически выделенный массив целых чисел                |
| i              | size_t     | Счётчик цикла для ввода элементов массива                              |
| ptr            | int*       | Указатель, используемый для обратного обхода массива                   |


### Код программы
```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    size_t n;
    printf("Enter number of elements: ");
    if (scanf("%zu", &n) != 1)
        return 1;

    int *arr = malloc(n * sizeof(int));
    if (!arr) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }

    printf("Enter %zu integers:\n", n);
    for (size_t i = 0; i < n; ++i) {
        if (scanf("%d", arr + i) != 1) {
            free(arr);
            return 1;
        }
    }

    printf("Elements in reverse order:\n");
    int *ptr = arr + n;      // point one past the last element
    while (ptr-- > arr) {    // decrement pointer, stop when it reaches arr
        printf("%d\n", *ptr);
    }

    free(arr);
    return 0;
}

```
### Результаты работы программы
![image](https://github.com/user-attachments/assets/d79991c2-e643-4252-8508-458e5c0f2963)

## Задача 6 – Побайтовый вывод переменной

### Постановка задачи 
 Определите переменную целого типа int a = 1234567890; и выведите побайтово её содержимое на экран,
 используя указатель char *.

### Список идентификаторов

| Имя переменной | Тип данных     | Смысловое обозначение                                           |
|----------------|----------------|------------------------------------------------------------------|
| a              | int            | Целое число, представление которого анализируется побайтово     |
| p              | char*          | Указатель на байтовое представление переменной `a`              |
| i              | size_t         | Счётчик цикла для обхода всех байтов переменной `a`             |


### Код программы
```c
#include <stdio.h>

int main(void) {
    int a = 1234567890;
    char *p = (char *)&a;

    printf("Byte-by-byte contents of a (decimal %d):\n", a);
    for (size_t i = 0; i < sizeof(a); ++i) {
        // cast to unsigned char to print a value 0–255
        printf("Byte %zu: 0x%02x\n", i, (unsigned char)p[i]);
    }

    return 0;
}

```
### Результаты работы программы
![image](https://github.com/user-attachments/assets/4ef33427-2afe-49b1-91c4-c6600ba1a8ef)

## Задача 7 – Двумерный динамический массив

### Постановка задачи
 Выделите память под двумерный динамический массив, используя массив указателей на строки (см. лекции), и
 затем корректно освободите оперативную память

### Список идентификаторов

| Имя переменной | Тип данных | Смысловое обозначение                                               |
|----------------|------------|----------------------------------------------------------------------|
| rows           | size_t     | Количество строк в двумерном массиве                                |
| cols           | size_t     | Количество столбцов в двумерном массиве                             |
| matrix         | int**      | Указатель на двумерный массив (массив указателей на массивы `int`)  |
| i              | size_t     | Счётчик цикла для создания и освобождения строк массива              |
| j              | size_t     | Счётчик вложенного цикла для освобождения ранее выделенной памяти    |


### Код программы
```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    size_t rows, cols;
    if (scanf("%zu %zu", &rows, &cols) != 2) return 1;
    int **matrix = malloc(rows * sizeof(int *));
    if (!matrix) return 1;
    for (size_t i = 0; i < rows; ++i) {
        matrix[i] = malloc(cols * sizeof(int));
        if (!matrix[i]) {
            for (size_t j = 0; j < i; ++j) free(matrix[j]);
            free(matrix);
            return 1;
        }
    }
    for (size_t i = 0; i < rows; ++i) free(matrix[i]);
    free(matrix);
    return 0;
}

```
### Результаты работы программы
![image](https://github.com/user-attachments/assets/45becfe0-5edc-436d-993b-5d6b98e98a17)

## Информация о студенте

Грижа Максим Игоревич ИВТ-1 ПГ-1


